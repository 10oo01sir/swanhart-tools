parallel.php:require_once('PHP-SQL-Parser/php-sql-parser.php');
parallel.php:	private $group = array(); //list of positions which contain non-aggregate functions
parallel.php:		$this->settings=array('engine'=>'MyISAM');
parallel.php:		if(!isset($settings)) $this->settings=array_merge($this->settings, $settings);
parallel.php:		$this->set_capability('MULTI_INPUT', TRUE);
parallel.php:		$this->set_capability('MULTI_OUTPUT', TRUE);
parallel.php:		$this->set_capability('RULE_NAME', 'PARALLEL_RULE');
parallel.php:		if(!isset($table_info)) $table_info = $this->table_info;
parallel.php:		if(!isset($process_info)) $process_info = $this->process_info;
parallel.php:		$this->table_info = $table_info;
parallel.php:		$this->process_info = $process_info;
parallel.php:				$sub_rewrite = new $THIS_CLASS($this->settings);
parallel.php:				$plan = $sub_rewrite->rewrite($sub_sql, $table_info, $process_info);
parallel.php:					$this->errors[] = $plan->errors;
parallel.php:		/* Handle single SQL (this can also come from a multi-plan that has recursed here */
parallel.php:		$this->sql = SELF::remove_comments($sql);
parallel.php:		$this->parsed = $REWRITE_PARSER->parse($this->sql);
parallel.php:		if(!SELF::is_select($this->parsed)) {
parallel.php:		$this->task_query = ""; //Query to send to each shard
parallel.php:		$this->final_query = ""; //Query to send to the coordination node
parallel.php:		$this->group = array(); //list of positions which contain non-aggregate functions
parallel.php:		$this->group_aliases = array(); //list of group aliases which will be indexed on the aggregation temp table
parallel.php:		$this->final_odku = array();
parallel.php:		$this->used_agg_func = 0;
parallel.php:		$this->non_distrib = false;
parallel.php:		$this->used_colrefs = array();
parallel.php:		$this->push_pos = 0;
parallel.php:		$this->straight_join = false;
parallel.php:		$this->errors = array();
parallel.php:		$this->used_agg_func = false;
parallel.php:		$this->push_select = array();
parallel.php:		$this->used_distinct = false;
parallel.php:		$this->no_pushdown_limit = false; //will be set if a rewrite forces us to abandon pushdown limit strategy
parallel.php:		$sig = md5($this->sql . uniqid());
parallel.php:		$this->table_name = "p" . $this->process_info['pid'] . "_agg_" . $sig;
parallel.php:		if (!$this->process_sql()) {
parallel.php:			$this->plan=false;
parallel.php:		$this->create_sql = "CREATE TABLE IF NOT EXISTS {$this->table_name} ";
parallel.php:		$create_subquery = str_replace('1=1','0=1', $this->task_sql[0]);
parallel.php:		if(stristr($this->task_sql[0], 'GROUP BY')) {
parallel.php:			if(!empty($this->agg_key_cols) && $this->agg_key_cols) $this->create_sql .= "(UNIQUE KEY gb_key (" . $this->agg_key_cols . "))";
parallel.php:		$this->create_sql .= " ENGINE=". $this->settings['engine'];
parallel.php:		$this->create_sql .= " AS $create_subquery ";
parallel.php:		foreach($this->task_sql as $idx => $sql) {
parallel.php:			$this->task_sql[$idx] = "INSERT INTO " . $this->table_name . " " . $sql;
parallel.php:		$plan[0] = $this->create_sql;
parallel.php:		$plan[1] = $this->task_sql; /* task_sql is an array for parallelism */
parallel.php:		if($this->used_distinct) {
parallel.php:			$this->DAL->my_query("alter table " . $this->table_name . " drop key gb_key");
parallel.php:		$plan[2] = $this->final_sql;
parallel.php:		$plan[4] = "DROP TABLE IF EXISTS " . $this->table_name;
parallel.php:		$this->plan = $plan;
parallel.php:		$parser_copy = $this->parsed;
parallel.php:			$this->errors[] = array(
parallel.php:			$this->errors[] = array(
parallel.php:			$select = $from = $where = $this->group = $order_by = "";
parallel.php:			$this->errors = array();
parallel.php:					$this->straight_join = true;
parallel.php:					$this->distinct = true;
parallel.php:				$this->with_rollup = "";
parallel.php:					$this->with_rollup = ' WITH ROLLUP';
parallel.php:					$this->errors[] = array(
parallel.php:					$this->errors[] = array(
parallel.php:					$this->errors[] = array(
parallel.php:				$this->errors[] = array(
parallel.php:				$this->errors[] = array(
parallel.php:			$processed_ok = $this->process_select();
parallel.php:			if (!$processed_ok || !empty($this->errors)) {
parallel.php:			if(trim($this->task_query) == 'SELECT') {
parallel.php:				$this->task_query = 'SELECT 1';
parallel.php:			if (!empty($parser_copy['GROUP']) && empty($this->final_group)) {
parallel.php:						$this->task_query .= "," . $gb['base_expr'] . ' AS `' . $id . '`';
parallel.php:						if ($this->final_group !== "") $this->final_group .= ',';
parallel.php:						$this->final_group .= $gb['base_expr'];
parallel.php:						if ($this->task_group !== "") $this->task_group .= ',';
parallel.php:						$this->task_group .= "`" . $id . "`";
parallel.php:			$this->task_group = ltrim($this->task_group,',');
parallel.php:			$this->final_group = ltrim($this->final_group,',');
parallel.php:			if ($having_info = $this->process_having($this)) {
parallel.php:					$this->task_query .= "," . $having_info['select'];
parallel.php:			$this->order_by = "";
parallel.php:							$this->errors[] = "Subqueries are not supported in the ORDER BY clause.\n";
parallel.php:							$this->errors[] = "Custom functions are not supported in the ORDER BY clause.\n";
parallel.php:							$this->concat_all_subtrees($o, $item);
parallel.php:							$this->task_query .= ", $item as $expr_alias";
parallel.php:										$this->final_odku[] = "$expr_alias=$expr_alias + VALUES($expr_alias)";
parallel.php:										$this->final_odku[] = "$expr_alias=IF($expr_alias < VALUES($expr_alias), VALUES($expr_alias),$expr_alias)";
parallel.php:										$this->final_odku[] = "$expr_alias=IF($expr_alias > VALUES($expr_alias), VALUES($expr_alias), $expr_alias)";
parallel.php:										$this->final_odku[] = "$expr_alias=$expr_alias + VALUES($expr_alias)";
parallel.php:								$this->task_query .= ", {$o['base_expr']} as $expr_alias";
parallel.php:				$this->order_by = " ORDER BY {$order_by}";
parallel.php:				$this->errors[] = array(
parallel.php:				$this->task_query .= "\n" . $this->process_from();
parallel.php:				foreach($this->table_info as $table_alias => $table_info) {
parallel.php:						$this->task_query=str_replace("%p$table_alias", "", $this->task_query); 
parallel.php:						unset($this->table_info[$table_alias]);
parallel.php:				if (!isset($this->table_name) || $this->table_name == "") {
parallel.php:					$this->table_name = "aggregation_tmp_" . mt_rand(1, 100000000);
parallel.php:				$this->final_query .= "\nFROM `$this->table_name`";
parallel.php:			//note that this will extract inlists and store them in $this->in_lists (if inlist optimization is on)	
parallel.php:			$where_clauses = $this->process_where();
parallel.php:			$this->used_limit = 0;
parallel.php:				$this->used_limit = 1;
parallel.php:				$this->errors[] = array(
parallel.php:			if (!empty($this->errors)) {
parallel.php:			if ($this->final_group)
parallel.php:				$this->final_group = ' GROUP BY ' . $this->final_group . $with_rollup;
parallel.php:			if ($this->task_group)
parallel.php:				$this->task_group = ' GROUP BY ' . $this->task_group;
parallel.php:			$queries = array($this->task_query);
parallel.php:			if(!empty($this->table_info)) {
parallel.php:					foreach($this->table_info as $table_alias => $table_info) {
parallel.php:				if (!$this->no_pushdown_limit) {
parallel.php:					$nq = $query . ' ' . $final_where_clause . ' ' . $this->task_group . ($this->used_limit ? $order_by : '');
parallel.php:					$nq = $query . ' ' . $final_where_clause . ' ' . $this->task_group;
parallel.php:		if (empty($this->final_group)) $this->final_group = "";
parallel.php:		if (empty($this->final_odku)) $this->final_odku = "";
parallel.php:		if (empty($this->task_group)) $this->task_group = "";
parallel.php:		$this->final_sql = $this->final_query . ' ' . $this->final_group . ' ' . $order_by;
parallel.php:		if (!isset($this->final_odku) || empty($this->final_odku))
parallel.php:			$this->final_odku = "";
parallel.php:		$this->task_sql = $queries;
parallel.php:		$this->agg_key_cols = ltrim($this->task_group,'GROUP BY ');
parallel.php:		$explain = "Shard-Query optimizer messages:";
parallel.php:		if ($this->agg_key_cols) {
parallel.php:			$explain .= "\n	* The following projections may be selected for a UNIQUE CHECK on the storage node operation:\n	{$this->agg_key_cols}\n";
parallel.php:			if ($this->final_odku)
parallel.php:				$explain .= "\n	* storage node result set merge optimization enabled:\n	ON DUPLICATE KEY UPDATE\n\t" . join(",\n\t", $this->final_odku);
parallel.php:		if (isset($this->messages)) {
parallel.php:			foreach ($this->messages as $msg) {
parallel.php:		$explain .= print_r($this->task_sql, true);
parallel.php:		$explain .= "SQL TO SEND TO COORDINATOR NODE:\n{$this->final_sql}\n";
parallel.php:		$this->explain = $explain;
parallel.php:				if(!in_array($clauses[$pos-1]['expr_type'], array('operator','reserved'))) {
parallel.php:					$this->concat_all_subtrees($clause['sub_tree'], $item, $depth + 1, $clause['expr_type']);
parallel.php:				$colrefs = array_merge($colrefs, $this->extract_colrefs($item['sub_tree']));
parallel.php:				$this->unquote_colrefs($item['sub_tree']);
parallel.php:				$this->unquote_colrefs($item);
parallel.php:				$alias = $this->concat_all_subtrees($clause, $item);
parallel.php:		$select = $this->parsed['SELECT'];
parallel.php:			$alias = $this->make_alias($clause);
parallel.php:			$this->process_select_item($pos, $clause, false, null, $alias, null);
parallel.php:				$this->task_query = rtrim($this->task_query, ", ");
parallel.php:				$this->final_query = rtrim($this->final_query, ", ");
parallel.php:				$this->task_query .= ",";
parallel.php:				$this->final_query .= ",";
parallel.php:		$this->task_query = rtrim($this->task_query, ", ");
parallel.php:		$this->final_query = rtrim($this->final_query, ", ");
parallel.php:		if ($this->straight_join)
parallel.php:		if ($this->distinct)
parallel.php:		$this->task_query = $sql . $this->task_query;
parallel.php:		$this->final_query = $sql . $this->final_query;
parallel.php:		foreach ($this->push_select as $clause) {
parallel.php:			$this->task_query .= "," . $clause;
parallel.php:		$this->group = join(',', $this->group);
parallel.php:		$this->group_aliases = join(',', array_unique($this->group_aliases));
parallel.php:		$this->no_pushdown_limit = true;
parallel.php:				$this->task_query .= "*";
parallel.php:				$this->final_query .= "*";
parallel.php:				if(!$parent || ($parent && $parent['expr_type'] !== 'expression')) $this->final_query .= $clause['base_expr'];
parallel.php:						$prev_clause = $clause['sub_tree'][$sub_pos - 1];
parallel.php:						$this->final_query .= $sub_clause['base_expr']; 
parallel.php:						$this->task_query .= ",";
parallel.php:					$this->process_select_item($pos, $sub_clause, true, $prev_clause,"", $clause);
parallel.php:				$this->final_query .= " $alias";
parallel.php:				$this->used_agg_func = 1;
parallel.php:				$base_expr = $this->concat_all_subtrees($clause['sub_tree'], $item);
parallel.php:							$this->messages[] = "DISTINCT aggregate expression used.	Pushing expression.\n";
parallel.php:							$this->no_pushdown_limit = true;
parallel.php:							if (empty($this->used_colrefs[trim($new_expr)])) {
parallel.php:								$this->task_query .= "$new_expr AS $new_alias";
parallel.php:								$this->final_odku[] = "$new_alias=VALUES($new_alias)";
parallel.php:								$this->group_aliases[] = $new_alias;
parallel.php:							$this->used_colrefs[trim($new_expr)] = 1;
parallel.php:							$this->final_query .= "{$function}(distinct $new_alias)"; 
parallel.php:							$this->used_distinct = true;
parallel.php:									$this->final_odku[] = "$new_alias=$new_alias + VALUES($new_alias)";
parallel.php:									$this->final_odku[] = "$new_alias=IF($new_alias < VALUES($new_alias), VALUES($new_alias),$new_alias)";
parallel.php:									$this->final_odku[] = "$new_alias=IF($new_alias > VALUES($new_alias), VALUES($new_alias), $new_alias)";
parallel.php:								$this->task_query .= "COUNT({$base_expr}) AS $new_alias";
parallel.php:								$this->final_query .= "SUM($new_alias)";
parallel.php:								$this->task_query .= "{$function}({$base_expr}) AS $new_alias";
parallel.php:								$this->final_query .= "{$function}({$new_alias})";
parallel.php:						if($alias && !$skip_alias)	$this->final_query .= " AS $alias";
parallel.php:							$this->messages[] = "Detected a {$function} [DISTINCT] expression!\n";
parallel.php:							if (empty($this->used_colrefs[trim($new_expr)])) {
parallel.php:								$this->task_query .= "$new_expr AS $alias";
parallel.php:								$this->final_odku[] = "$alias=VALUES($alias)";
parallel.php:								$this->group_aliases[] = $alias;
parallel.php:							$this->final_query .= "{$function}(distinct $alias)" . (!$skip_alias ? " AS $alias" : "");
parallel.php:							$this->task_query .= "SUM({$base_expr}) AS $alias";
parallel.php:							$this->final_query .= "SUM({$alias})/SUM({$alias_cnt})" . (!$skip_alias ? " AS $alias" : "");
parallel.php:							$this->push_select[] = "COUNT({$base_expr}) as {$alias_cnt}";
parallel.php:							$this->final_odku[] = "{$alias_cnt} = {$alias_cnt} + VALUES({$alias_cnt})";
parallel.php:						$this->errors[] = array(
parallel.php:				$this->final_query .= $base_expr;
parallel.php:				if(!$parent) $this->final_query .= " AS $alias";
parallel.php:				$this->no_pushdown_limit = true;
parallel.php:				$this->final_query .= $base_expr . "(";
parallel.php:						$this->process_select_item($pos + 1, $sub_clause, true, $clause, "", $clause);
parallel.php:						$this->final_query .= " " . $sub_clause['base_expr'];
parallel.php:				$this->final_query .= ") $alias";
parallel.php:				if (empty($this->used_colrefs[$base_expr])) {
parallel.php:					$new_alias	= "expr$" . (count($this->used_colrefs));
parallel.php:					$new_alias = "expr$" . $this->used_colrefs[$base_expr];
parallel.php:					$this->final_query .= $new_alias . ' AS ' . $alias;
parallel.php:					$this->task_query .= $clause['base_expr'] . ' AS ' . $new_alias;
parallel.php:					$this->group[] = $pos + 1;
parallel.php:					$this->group_aliases[] = $new_alias;
parallel.php:					if (empty($this->used_colrefs[$base_expr])) {
parallel.php:						$new_alias	= "expr$" . (count($this->used_colrefs));
parallel.php:						$this->task_query .= $base_expr;
parallel.php:							$this->task_query .= ' AS ' . $new_alias;
parallel.php:						$this->task_query .= ",";
parallel.php:						$this->group_aliases[] = $new_alias;
parallel.php:					$this->final_query .= " $new_alias";
parallel.php:				if (empty($this->used_colrefs[$base_expr])) {
parallel.php:					$this->used_colrefs[$base_expr] = count($this->used_colrefs);
parallel.php:				$this->errors[] = array(
parallel.php:		$tables = $this->parsed['FROM'];	
parallel.php:				$this->errors[] = array(
parallel.php:				$sub_this->table_name = $sub_table_name;
parallel.php:				$sub_this->DAL = SimpleDAL::factory($sub_this->tmp_shard);
parallel.php:				$this->query($table['sub_tree'], false, $sub_this, true, false);
parallel.php:				$this->dependent_subqueries[] = $sub_table_name;
parallel.php:				$this->extra_tables[] = $sub_table_name;
parallel.php:				$this->extra_tables = array_merge($this->extra_tables, $sub_this->extra_tables);
parallel.php:				$sql = '(' . $sub_this->final_sql . ')';
parallel.php:				$db = $this->process_info['current_schema'];
parallel.php:				$this->tables[$table_name] = array(
parallel.php:			$this->concat_all_subtrees($tables[$i]['ref_clause'],$item);
parallel.php:				$this->concat_all_subtrees($tables[$i]['ref_clause'],$item);
parallel.php:		if(!isset($where)) $where = $this->parsed['WHERE'];
parallel.php:			$this->append_all($queries, " ");
parallel.php:				$new_queries = $this->process_where($clause['sub_tree']);
parallel.php:			$this->append_all($queries, $clause['base_expr']);
parallel.php:		if(!isset($this)) $this = $this->this;
parallel.php:		if (!$this->DAL->my_select_db($this->tmp_shard['db'])) {
parallel.php:			$this->errors[] = 'While aggregating result: ' . $this->DAL->my_error();
parallel.php:			if (!$stmt = $this->DAL->my_query($this->final_sql)) {
parallel.php:				$this->errors[] = 'While aggregating result: ' . $this->DAL->my_error();
README.md:This is basically "shard-query-lite".  All gearman features and all sharding features are removed.  
rewriteengine.php:require_once('PHP-SQL-Parser/php-sql-parser.php');
rewriteengine.php:		$this->settings = $settings;
rewriteengine.php:		$this->set_capability('MULTI_INPUT', FALSE);
rewriteengine.php:		$this->set_capability('MULTI_OUTPUT', TRUE);
rewriteengine.php:		$this->set_capability('RULE_NAME', 'BASE_RULE');
rewriteengine.php:		$plan = $planner->rewrite($s, $t, $p, $settings);
rewriteengine.php:		if(!empty($planner->errors)) {
rewriteengine.php:			$plan['errors'] = $planner->errors;
rewriteengine.php:		$plan['errors'] = $planner->errors;
rewriteengine.php:		return(preg_replace( array("%-- [^\\n](?:\\n|$)%", "%/\\*.*\\*/%"), '', $sql ));
rewriteengine.php:		return(!empty($this->caps[$cap]) && $this->caps[$cap] == TRUE);
rewriteengine.php:		return($this->caps[$cap] = $value);
rewriteengine.php:		if(!empty($this->settings[$key])) return($this->settings[$key]);
rewriteengine.php:		if(!empty($this->defaults[$key])) return($this->defaults[$key]);
rewriteengine.php:		$this->settings[$key] = $val;
